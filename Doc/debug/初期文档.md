# Day 1.创建组和QEMU环境编译

## 实验过程

### NPUCore线程

上午组会成后各自行动,我们尝试编译了NPUCore但只进入了最基本的死循环下(也就是OpenSBI+打印系统信息的画面),自己写的测试用例无论如何都无法正常运行(黄赵翔是更成功的,他找到了从修改后的Makefile编译自定义的程序进入文件系统的方法,但仍然无法运行),我则找到了其中一个入口,但也无法打印任何"hello, world"信息 ,后经过助教点拨,需要将BASEADDR改成0x02000才行,但也没成功.

### UltraOS线程

在下午3点左右,见毫无进展,我去康班爷那里观察进度;黄赵翔则开始转战rCore;我发现他们4人中的2个已经完成了编译工作,才意识到他们是在编译哈工大UltraOS,于是我尝试转战Ultra,但由于和黄赵翔使用了不同的分支(我用了来自Gitlab的官方Repo,他则是一个来自Gitee的),产生了部分问题并导致实验完成时间的延后;最后,晚上黄赵翔完成了对binutils问题的解决方案2



# Day 2 上板
### 2. 解决Load Page Fault

暂时绕过内存不足的问题后，我们继续尝试加载BusyBox，但又遇到了新的问题：

![Load Page Fault](/profile/upload/2021/11/22/7b9ea4109425d13d6f59e3ee4fd9fd57.png "Load Page Fault")

如图，从日志记录可以看出，报错是在sys_exec()执行完毕之后。结合gdb断点调试和odbdump反汇编检查，我们发现出错位置属于BusyBox的执行流，而出错时BusyBox还未触发任何系统调用。

通过在网上查找学习一些资料，我们大致了解了BusyBox的启动流程（[linux内核如何启动busybox](https://blog.csdn.net/guodongsoft/article/details/52534617 "linux内核如何启动busybox")），最后我们将问题定位到sys_exec()系统调用：

rcore实现的sys_exec()与linux的实现不一致，具体体现在放置参数时，参数在用户栈空间的布局不同。在rcore中，参数指针在高地址，实际的字符串参数在低地址，而linux的实现恰好相反。导致BusyBox的主函数读取参数错误，进而错误访存导致Load Page Fault。

那么只要修复sys_exec()，与linux保持一致即可：

![修复成功](/profile/upload/2021/11/22/d43f7db4d2f03982d2aceadec472720f.png)

如图，修复后Load Page Fault不再出现，BusyBox成功加载并触发了一个未实现的系统调用。

## GDB
GDB方向上,我修改了脚本尝试编译运行debug,将Makefile加入debug分支,把构建目标改成dev分支,之后gdb-multiarch,在gdb中

````
target remote localhost:1234
````

但发现程序编译出来后,运行时会卡在shell加载,而另一方面,gdb则无法加载符号,而且拒绝连接qemu;如果使用release分支,其dbginfo都被删除,无法加载,尝试研究问题所在

之后参考清华的教程其方案是运行release,但gdb加载debug分支,但是很奇怪,在我的计算机上,如这样做,会无法停止在断点上,可能是地址不同的缘故;

如果改用dev分支并打开优化,就会出现奇怪的overflow问题,然后panic,也许是打开了检查?

最后,考虑加入debuginfo给release版,在Cargo.toml中,加入

````
[profile.release]
debug=true

````

正常运行

![](/profile/upload/2021/11/21/18236cd8ea2f82bbfdf276bf9dd76418.png)

目前在尝试将两个分支独立开来,用同一个Makefile,同一个toml运行
之后尝试运行了清华的mmap测试用例,发现某用例没通过,重读说明后发现要求没对齐直接退出,而不是没对齐就自动矫正为对齐的版本

# 第三周
## 非法指令问题
在解决完elf段偏移的问题后,黄赵翔发现运行busybox sh命令会产生很奇怪的非法指令崩溃,按照之前的思维惯性,自然是去考虑是否还有加载和内存方面的问题.

于是,开始尝试反编译,他先反汇编了代码,注意到busybox崩溃的语句是"unknown"语句,按照之前反汇编的经验认为是辅助向量,于是添加了辅助向量的加载处理
![](/profile/upload/2021/11/29/8c91ca45e7c7d1de3a4fc23ceb7cd1f4.jpg)
但继续执行还是非法指令错,这次换了个地方.

于是,他先使用之前编译的带符号版本的busybox进行gdb调试,虽然成功地切换到了执行流,但是并没有解决

首先是尝试gdb调试,加上中间变量的输出,但一无所获;

之后,他又怀疑是由于出现了内存方面的问题,于是在所有可能的地方插入了sfence,刷新缓存虚拟页面,但没有成功;

之后又开始尝试从其他角度入手,也没有进展,偶然想到哈工大的版本平台和我们常见的gc版本目标(带浮点数的完整CPU实现)不同,于是切换到对有符号版本进行反编译,然后发现其未知语句是fsd,也就是存浮点数指令;之后,于是开始怀疑是否真的是相对于平台和编译测试环境而言是非法指令.理论上来说,如果是浮点数未支持的问题,那么在板子上应当能跑通. 为了验证,他要求我在板子上执行(板子不在他手里),然后发现了思路是对的:的确成功地运行了指令,在未支持的系统调用上退出了.
![](/profile/upload/2021/11/29/f5933737dd090ea5f7898946c35ad512.jpg)
联系到之前观察哈工大的模拟器使用的是imac版本(无浮点数),可能说明其也意识到这个问题,于是改用没有浮点数的编译目标平台,从而强制指定用整数实现浮点数匀速,以及其使用OpneSBI的原因,也许是RustSBI本身不支持浮点数,之后去查找哈工大的文档也进一步验证了这样的想法.哈工大的确是这么处理的.于是后续的工作集中在替换RustSBI(相当于Bootloader)为OpenSBI上

除此之外,黄赵翔还补充了部分api(主要是文件部分),从而成功运行了ls,wc等
![](/profile/upload/2021/11/29/8b7e752569701e26eaafce387df47169.jpg)
![](/profile/upload/2021/11/29/7d5cc4c464d15be3ae4ef37863bef06c.jpg)

## 加载的内存分配问题

经过思考,我们发现其实并不需要完整的mmap就可以解决内存的分配问题.

首先强调,在运行加载程序(task::new和exec())的时候,显然,实际上是个系统调用,那么就发生在系统的内核地址空间,这样以来,问题就是如何在
之所以会产生内存不足的问题,是因为rCore内核堆本身使用buddy_system进行内存分配,实际上是向上取整到下一个二进制的数字的内存大小.

Busybox本身程序大小1.1MiB,也就是需要2MiB的空闲空间,至少需要一半的内核堆,再加上其还是复制到内存中执行,加载同时其最大需要的空间至少是6MiB,同时永远需要维护至少4MiB的内核堆大小,这样的开销无法接受

问题就是如何找一块内核地址空间的空位进行复制过程

如图,通过rCore教材,可以发现在低地址空间上,0~8MiB的位置都被占用,只有8MiB之上的空间才未被使用(一直到256GiB);高地址空间上,除了用于内容切换的跳板部分,就是内核栈和保护页面.为了保护其系统调用和更好地发现问题,清华的处理是不在其保护页面上申请任何的虚拟地址,如果有任何针对保护页面的地址访问,就会出发异常,且可能会碰到已经申请过的某些地址,便无法将其作为连续的区段进行加载复制的工作.而对于低地址空间,MEMORY_END之上的位置从复制结束开始就没有任何的动作,可以作为缓存暂存程序. 此外,使用调用清华的页表分配函数形成的自己的内存分配函数进行alloc和munmap进行分配即可,的确,刚开始运行良好,说明至少虚拟内存是正确回收了

本以为到这里就结束了,黄赵翔方面经过测试发现这个问题存在内存泄露.

接下来我以为问题出在合并的代码(黄赵翔的elf)上,切换分支到过去的历史后,发现虽然正常运行,但是之所以不产生问题是因为我只测了一次,而内存泄露往往要耗尽内存才能出现.

之后由于以为问题出在其自动回收机制上,先实现了完整的手动回收,发现内存总量倒是不缺少了,也确实可以多次复制,多次执行,但是每次执行都会发生严重的指令页缺页,除了第一次,说明一开始是正常加载,但是后面的加载是错误的,也就是说回收机制仍然没有完成

最后,通过输出释放的页表地址的结果发现,实际上是因为我将虚拟地址作为页表号传入,导致实际分配和使用的物理页表不同,所以只释放了虚拟地址,没有释放物理地址.加上我每次使用的new的mapArea实际上是新生成的,其内部用于映射虚拟地址到物理地址的B树是空的,其根本无法触发

可见,

问题接下来就是如何复制.参考之前使用的`read_all()`实现,只需要重实现一个`read_into()`,将复制来的文件复制即可.


### 关于日志系统的设计和完整化

为了后续工作的顺利进行,我们引入了日志系统:黄赵翔使用官方的LOG库,对make
使用LOG=trace即可打开所有的

其使用的API是env_option!(LOG)

另外,我将unsupported syscall处理改为exit(-1)并打印所有参数,从而实现尽可能少的接口模式

# 考后第一周
既然考完了, 我就先做(shui)一个小的系统调用放松一下,
## 具体目标
直接目的是实现运行busybox sh(自带shell的功能),其在输入的过程中依赖ppoll(现在的新版已经替换成poll了,但是2020届比赛的官方测试样例使用的busybox版本仍然使用ppoll,但实际上需要的功能是一样的.)
## 节外生枝
完成了这些工作,却还是没有成功完成执行的内容: 出现下列提示,
![](/profile/upload/2021/12/26/d2eec574c472cd139933bacb39818867.png)
观察后发现是哈工大实现的Fat32不支持只有后缀名的文件名,所以...暂时写到这里
